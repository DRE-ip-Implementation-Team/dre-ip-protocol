use std::collections::HashMap;
use std::hash::Hash;
use std::ops::{Add, Mul, Sub};
use num_bigint::BigUint;
use num_traits::{One, Zero};
use rand::{CryptoRng, RngCore};

pub mod groups;

use crate::groups::{DreipGroup, DreipPoint, DreipScalar, Serializable};

/// Zero-Knowledge Proof of well-formedness that a vote has `v` in `{0, 1}`.
#[derive(Debug, Eq, PartialEq)]
pub struct VoteProof {
    /// Challenge value one.
    pub c1: BigUint,
    /// Challenge value two.
    pub c2: BigUint,
    /// Response value one.
    pub r1: BigUint,
    /// Response value two.
    pub r2: BigUint,
}

impl VoteProof {
    /// Create a new proof.
    ///
    /// This proof consists of two parallel sub-proofs, one of which will be
    /// genuine, and the other faked. Due to the way the sub-challenges `c1`
    /// and `c2` must sum to the total challenge `c`, it is impossible for both
    /// to be faked. Thus, if they both verify correctly, then we have proved
    /// their disjunction without revealing which is true.
    ///
    /// Our sub-proofs are for `v=0` and `v=1`, so our overall proof is `v=0 OR v=1`.
    ///
    /// A genuine sub-proof works as follows:
    /// 1. A random scalar `rand` is generated.
    /// 2. We calculate `a = g1 * rand` and `b = g2 * rand`.
    /// 3. We generate a challenge value `c`, and receive the sub-challenge `c' = c - fake_c`,
    ///    where `fake_c` is the pre-selected sub-challenge for the fake proof.
    /// 4. We calculate our response as `resp = rand - secret * c'`, where `secret` is `vote.r`.
    /// 5. The observer can verify that `a = g1*resp + Y*c'`, where `Y` is either `Z` or `Z - g1`
    ///    depending on whether we are trying to prove v=0 or v=1 respectively. This holds, as:
    /// ```equation
    ///           g1*resp + Y*c'
    ///         = g1*(rand - secret*c') + g1*(secret*c')
    ///         = g1*(rand - secret*c' + secret*c')
    ///         = g1*rand
    ///         = a
    /// ```
    /// 6. The observer can verify that `b = g2*resp + R*c'`. This holds, as:
    /// ```equation
    ///           g2*resp + R*c'
    ///         = g2*(rand - secret*c') + g2*(secret*c')
    ///         = g2*(rand - secret*c' + secret*c')
    ///         = g2*rand
    ///         = b
    /// ```
    ///
    /// A fake sub-proof works as follows:
    /// 1. We pre-select our sub-challenge `c'` and response `resp` by randomly generating them.
    /// 2. We calculate `a = g1*resp + Y*c'`, where `Y` is either `Z` or `Z - g1` depending on whether
    ///    we are trying to fake v=0 or v=1 respectively.
    /// 3. We calculate `b = g2*resp + R*c'`.
    /// 4. The observer can verify that `a = g1*resp + Y*c'` and `b = g2*resp + R*c'`; these trivially
    ///    hold due to the way in which we constructed them.
    ///
    /// Since the total challenge `c` is generated by a hash function and is thus out of our control,
    /// we can only pick the sub-challenge for one of the two sub-proofs, the other must necessarily
    /// use a value such that the sub-challenges sum to `c`; this is enforced by the observer
    /// additionally verifying that `c1 + c2 = c`.
    ///
    /// Therefore, only one of the two sub-proofs can be faked, and we have successfully formed our
    /// zero-knowledge proof of the disjunction.
    ///
    /// The ballot and candidate ids are part of the hash input for the challenge, tying the
    /// proof to the vote. This requires that the combination of the two is globally unique.
    ///
    /// This function does not check the validity of the generated proof, so if
    /// the supplied `v`, `r`, `Z`, and `R` values are invalid, an invalid
    /// proof will be generated.
    ///
    /// See the `Election` impl block for an explanation of the scary-looking trait constraints.
    #[allow(non_snake_case)]
    pub fn new<G>(mut rng: impl RngCore + CryptoRng, election: &Election<G>,
                  v: bool, r: &G::Scalar, Z: &G::Point, R: &G::Point,
                  ballot_id: impl AsRef<[u8]>,
                  candidate_id: impl AsRef<[u8]>) -> Self
    where
        G: DreipGroup,
        for<'a> &'a G::Point:
            Add<Output = G::Point> +
            Sub<Output = G::Point> +
            Mul<&'a G::Scalar, Output = G::Point>,
        for<'a> &'a G::Scalar:
            Add<Output = G::Scalar> +
            Sub<Output = G::Scalar> +
            Mul<Output = G::Scalar>
    {
        // Get our generators.
        let g1 = election.g1();
        let g2 = election.g2();

        // Generate the input for our genuine proof.
        let random_scalar = G::Scalar::random(&mut rng);
        let genuine_a = g1 * &random_scalar;
        let genuine_b = g2 * &random_scalar;

        // Generate our response and sub-challenge for the faked proof.
        let fake_response = G::Scalar::random(&mut rng);
        let fake_challenge = G::Scalar::random(&mut rng);

        // Our fake_a varies depending on the vote.
        let fake_a = if v {
            // Fake proof for v=0, since v really equals 1.
            &(g1 * &fake_response) + &(Z * &fake_challenge)
        } else {
            // Fake proof for v=1, since v really equals 0.
            &(g1 * &fake_response) + &( &(Z - g1) * &fake_challenge)
        };
        // Our fake_b is always the same.
        let fake_b = &(g2 * &fake_response) + &(R * &fake_challenge);

        // Ensure our `a` and `b` values are always in the right order (proof for v=0 first).
        let (a1, b1, a2, b2) = if v {
            (fake_a, fake_b, genuine_a, genuine_b)
        } else {
            (genuine_a, genuine_b, fake_a, fake_b)
        };

        // Get our non-interactive challenge via hashing.
        let challenge = G::Scalar::from_hash(&[
            &g1.to_bytes(), &g2.to_bytes(), &Z.to_bytes(), &R.to_bytes(),
            &a1.to_bytes(), &b1.to_bytes(), &a2.to_bytes(), &b2.to_bytes(),
            ballot_id.as_ref(), candidate_id.as_ref(),
        ]);
        // Split this into sub-challenges.
        let genuine_challenge = &challenge - &fake_challenge;
        // Calculate the genuine response.
        let genuine_response = &random_scalar - &(r * &genuine_challenge);

        // Re-order the values so (c1, r1) are always the proof for v=0 and
        // (c2, r2) are always the proof for v=1, regardless of which is fake.
        let (c1, c2, r1, r2) = if v {
            (fake_challenge, genuine_challenge, fake_response, genuine_response)
        } else {
            (genuine_challenge, fake_challenge, genuine_response, fake_response)
        };

        VoteProof {
            c1: c1.to_bigint(),
            c2: c2.to_bigint(),
            r1: r1.to_bigint(),
            r2: r2.to_bigint(),
        }
    }

    /// Verify the given proof, returning `Some(())` if verification succeeds and `None` otherwise.
    #[allow(non_snake_case)]
    pub fn verify<G>(&self, election: &Election<G>, Z: &BigUint, R: &BigUint,
                     ballot_id: impl AsRef<[u8]>, candidate_id: impl AsRef<[u8]>) -> Option<()>
    where
        G: DreipGroup,
        G::Scalar: Eq,
        for<'a> &'a G::Point:
            Add<Output = G::Point> +
            Sub<Output = G::Point> +
            Mul<&'a G::Scalar, Output = G::Point>,
        for<'a> &'a G::Scalar:
            Add<Output = G::Scalar> +
            Sub<Output = G::Scalar> +
            Mul<Output = G::Scalar>
    {
        // Get our generators.
        let g1 = election.g1();
        let g2 = election.g2();

        // Reconstruct values from bigints.
        let Z = G::Point::new(Z)?;
        let R = G::Point::new(R)?;
        let c1 = G::Scalar::new(&self.c1)?;
        let c2 = G::Scalar::new(&self.c2)?;
        let r1 = G::Scalar::new(&self.r1)?;
        let r2 = G::Scalar::new(&self.r2)?;

        // Reconstruct the `a` and `b` values.
        let a1 = &(g1 * &r1) + &(&Z * &c1);
        let b1 = &(g2 * &r1) + &(&R * &c1);
        let a2 = &(g1 * &r2) + &(&(&Z - g1) * &c2);
        let b2 = &(g2 * &r2) + &(&R * &c2);

        // Reconstruct the challenge value.
        let challenge = G::Scalar::from_hash(&[
            &g1.to_bytes(), &g2.to_bytes(), &Z.to_bytes(), &R.to_bytes(),
            &a1.to_bytes(), &b1.to_bytes(), &a2.to_bytes(), &b2.to_bytes(),
            ballot_id.as_ref(), candidate_id.as_ref(),
        ]);

        // Ensure that the challenge value matches.
        if &c1 + &c2 == challenge {
            Some(())
        } else {
            None
        }
    }
}

/// Proof of well-formedness that a ballot has exactly one positive vote.
#[derive(Debug, Eq, PartialEq)]
pub struct BallotProof {
    /// Proof value a.
    pub a: BigUint,
    /// Proof value b.
    pub b: BigUint,
    /// Response value.
    pub r: BigUint,
}

impl BallotProof {
    /// Create a new proof.
    ///
    /// This proof works on a similar principle to the genuine sub-proof within `VoteProof`.
    /// It works as follows:
    /// 1. We generate a random scalar `rand`.
    /// 2. We calculate `a = g1 * rand` and `b = g2 * rand`.
    /// 3. We generate a challenge value `c` which we cannot control due to the use of a hash function.
    /// 4. We calculate our response as `resp = rand + c * r_sum`, where `r_sum` is the sum of secret
    ///    `r` values across all votes in this ballot.
    /// 5. The observer can verify that `g1*resp = a + X*c`, where `X = sum(vote.Z) - g1` across
    ///    all votes in this ballot; this holds, as:
    /// ```equation
    ///           sum(vote.Z) = g1 * sum(vote.r) + g1
    ///        so X = g1 * r_sum
    ///        so a + X*c
    ///         = g1*rand + g1*(r_sum*c)
    ///         = g1 * (rand + c * r_sum)
    ///         = g1 * resp
    /// ```
    ///    If the number of yes votes is anything other than 1, then `sum(vote.Z)` will be
    ///    different and the proof would fail.
    /// 6. The observer can verify that `g2*resp = b + Y*c`, where `Y = sum(vote.R)` across all
    ///    votes in this ballot; this holds, as:
    /// ```equation
    ///           sum(vote.R) = g2 * sum(vote.r)
    ///        so Y = g2 * r_sum
    ///        so b + Y*c
    ///         = g2*rand + g2*(r_sum*c)
    ///         = g2 * (rand + c * r_sum)
    ///         = g2 * resp
    /// ```
    ///
    /// The ballot id is part of the hash input for the challenge, tying the proof to the ballot.
    /// This requires that the ballot id is unique.
    pub fn new<G: DreipGroup>(mut rng: impl RngCore + CryptoRng, election: &Election<G>,
                              r_sum: &G::Scalar, ballot_id: impl AsRef<[u8]>) -> Self
    where
        G: DreipGroup,
        for<'a> &'a G::Point:
            Add<Output = G::Point> +
            Sub<Output = G::Point> +
            Mul<&'a G::Scalar, Output = G::Point>,
        for<'a> &'a G::Scalar:
            Add<Output = G::Scalar> +
            Sub<Output = G::Scalar> +
            Mul<Output = G::Scalar>
    {
        // Get our generators.
        let g1 = election.g1();
        let g2 = election.g2();

        // Generate the input for the challenge.
        let random_scalar = G::Scalar::random(&mut rng);
        let a = g1 * &random_scalar;
        let b = g2 * &random_scalar;

        // Get our non-interactive challenge via hashing.
        let challenge = G::Scalar::from_hash(&[
            &g1.to_bytes(), &g2.to_bytes(), &a.to_bytes(), &b.to_bytes(), ballot_id.as_ref(),
        ]);

        // Calculate the response.
        let response = &random_scalar + &(&challenge * r_sum);

        BallotProof {
            a: a.to_bigint(),
            b: b.to_bigint(),
            r: response.to_bigint(),
        }
    }

    /// Verify the given proof, returning `Some(())` if verification succeeds and `None` otherwise.
    #[allow(non_snake_case)]
    pub fn verify<G>(&self, election: &Election<G>, Z_sum: &G::Point, R_sum: &G::Point,
                     ballot_id: impl AsRef<[u8]>) -> Option<()>
    where
        G: DreipGroup,
        G::Point: Eq,
        for<'a> &'a G::Point:
            Add<Output = G::Point> +
            Sub<Output = G::Point> +
            Mul<&'a G::Scalar, Output = G::Point>,
        for<'a> &'a G::Scalar:
            Add<Output = G::Scalar> +
            Sub<Output = G::Scalar> +
            Mul<Output = G::Scalar>
    {
        // Get our generators.
        let g1 = election.g1();
        let g2 = election.g2();

        // Reconstruct values from bigints.
        let a = G::Point::new(&self.a)?;
        let b = G::Point::new(&self.b)?;
        let r = G::Scalar::new(&self.r)?;

        // Reconstruct the challenge value.
        let challenge = G::Scalar::from_hash(&[
            &g1.to_bytes(), &g2.to_bytes(), &a.to_bytes(), &b.to_bytes(), ballot_id.as_ref(),
        ]);

        // Verify the first equation.
        let X = Z_sum - g1;
        if g1 * &r != &a + &(&X * &challenge) {
            return None;
        }

        // Verify the second equation.
        if g2 * &r != &b + &(R_sum * &challenge) {
            return None;
        }

        Some(())
    }
}

/// A single vote, representing a yes/no value for a single candidate.
#[allow(non_snake_case)]
#[derive(Debug, Eq, PartialEq)]
pub struct Vote {
    /// The secret random value.
    pub r: BigUint,
    /// The secret vote value: 1 for yes or 0 for no.
    pub v: BigUint,
    /// The public R value (g2^r).
    pub R: BigUint,
    /// The public Z value (g1^(r+v)).
    pub Z: BigUint,
    /// The proof of well-formedness that guarantees `R` and `Z` were calculated correctly.
    pub pwf: VoteProof,
}

impl Vote {
    /// Verify the PWF of this vote.
    pub fn verify<G>(&self, election: &Election<G>,
                     ballot_id: impl AsRef<[u8]>, candidate_id: impl AsRef<[u8]>) -> bool
    where
        G: DreipGroup,
        G::Scalar: Eq,
        for<'a> &'a G::Point:
            Add<Output = G::Point> +
            Sub<Output = G::Point> +
            Mul<&'a G::Scalar, Output = G::Point>,
        for<'a> &'a G::Scalar:
            Add<Output = G::Scalar> +
            Sub<Output = G::Scalar> +
            Mul<Output = G::Scalar>
    {
        self.pwf.verify(election, &self.Z, &self.R, ballot_id, candidate_id).is_some()
    }
}

/// A single ballot, representing a yes for exactly one candidate across a set of candidates.
/// The type parameter `K` is the candidate ID type.
#[derive(Debug)]
pub struct Ballot<K> {
    /// Map from candidate IDs to individual votes.
    pub votes: HashMap<K, Vote>,
    /// The proof of well-formedness that guarantees exactly one of the `votes` represents yes.
    pub pwf: BallotProof,
    /// The signature of the ballot, verifying authenticity and integrity.
    pub signature: Box<[u8]>,
}

impl<K> Ballot<K> {
    /// Verify all PWFs within this ballot.
    #[allow(non_snake_case)]
    pub fn verify<G>(&self, election: &Election<G>, ballot_id: impl AsRef<[u8]>) -> bool
    where
        K: AsRef<[u8]>,
        G: DreipGroup,
        G::Point: Eq,
        G::Scalar: Eq,
        for<'a> &'a G::Point:
            Add<Output = G::Point> +
            Sub<Output = G::Point> +
            Mul<&'a G::Scalar, Output = G::Point>,
        for<'a> &'a G::Scalar:
            Add<Output = G::Scalar> +
            Sub<Output = G::Scalar> +
            Mul<Output = G::Scalar>
    {
        // Verify individual vote proofs.
        let votes_valid = self.votes.iter()
            .all(|(candidate, vote)| vote.verify(election, &ballot_id, candidate));
        if !votes_valid {
            return false;
        }

        // Verify the ballot proof.
        let Z_values = self.votes.values()
            .map(|vote| G::Point::new(&vote.Z))
            .collect::<Option<Vec<_>>>();
        let Z_sum: G::Point = match Z_values {
            Some(zv) => {
                let zero = G::Point::new(&BigUint::zero()).unwrap();
                zv.into_iter().fold(zero, |a, b| &a + &b)
            },
            None => return false,
        };
        let R_values = self.votes.values()
            .map(|vote| G::Point::new(&vote.R))
            .collect::<Option<Vec<_>>>();
        let R_sum = match R_values {
            Some(rv) => {
                let zero = G::Point::new(&BigUint::zero()).unwrap();
                rv.into_iter().fold(zero, |a, b| &a + &b)
            },
            None => return false,
        };
        let ballot_valid = self.pwf.verify(election, &Z_sum, &R_sum, ballot_id);
        ballot_valid.is_some()
    }
}

/// An election using the given group.
#[derive(Debug)]
pub struct Election<G: DreipGroup> {
    /// First generator.
    g1: G::Point,
    /// Second generator.
    g2: G::Point,
    /// Signing key.
    private_key: G::PrivateKey,
    /// Verification key.
    public_key: G::PublicKey,
}

/// Our trait constraints look scary here, but they simply require arithmetic to
/// be defined on our group. The first set is point arithmetic, structured like
/// an additive group (a multiplicative group could easily be converted with
/// a wrapper type). The second set is scalar arithmetic.
impl<G> Election<G> where
    G: DreipGroup,
    for<'a> &'a G::Point:
        Add<Output = G::Point> +
        Sub<Output = G::Point> +
        Mul<&'a G::Scalar, Output = G::Point>,
    for<'a> &'a G::Scalar:
        Add<Output = G::Scalar> +
        Sub<Output = G::Scalar> +
        Mul<Output = G::Scalar>
{
    /// Create a new election.
    pub fn new(unique_bytes: &[&[u8]], rng: impl RngCore + CryptoRng) -> Self {
        let (g1, g2) = G::new_generators(unique_bytes);
        let (private_key, public_key) = G::new_keys(rng);
        Self {
            g1,
            g2,
            private_key,
            public_key,
        }
    }

    /// Get the first generator.
    pub fn g1(&self) -> &G::Point {
        &self.g1
    }

    /// Get the second generator.
    pub fn g2(&self) -> &G::Point {
        &self.g2
    }

    /// Get the public key.
    pub fn public_key(&self) -> &G::PublicKey {
        &self.public_key
    }

    /// Create a new ballot, representing a yes vote for the given candidate, and a no vote for all
    /// the other given candidates.
    /// This will fail if any candidate IDs are duplicates.
    pub fn create_ballot<B, C>(&self, mut rng: impl RngCore + CryptoRng, ballot_id: B,
                               yes_candidate: C, no_candidates: Vec<C>) -> Option<Ballot<C>>
    where
        B: AsRef<[u8]>,
        C: AsRef<[u8]> + Eq + Hash,
    {
        let num_candidates = no_candidates.len() + 1;
        let mut votes = HashMap::with_capacity(num_candidates);

        // Create yes vote.
        let yes_vote = self.create_vote(&mut rng, &ballot_id, &yes_candidate, true);
        ensure_none(votes.insert(yes_candidate, yes_vote))?;
        // Create no votes.
        for candidate in no_candidates {
            let no_vote = self.create_vote(&mut rng, &ballot_id, &candidate, false);
            ensure_none(votes.insert(candidate, no_vote))?;
        }
        // Create PWF.
        let zero = G::Scalar::new(&BigUint::zero()).unwrap();
        let r_sum: G::Scalar = votes.values()
            .map(|vote| G::Scalar::new(&vote.r).expect("Infallible"))
            .fold(zero, |a, b| &a + &b);
        let pwf = BallotProof::new(rng, self, &r_sum, &ballot_id);

        // TODO create signature.
        let signature = vec![].into_boxed_slice();

        Some(Ballot {
            votes,
            pwf,
            signature,
        })
    }

    #[allow(non_snake_case)]
    pub fn create_vote<B, C>(&self, rng: impl RngCore + CryptoRng,
                             ballot_id: B, candidate: C, yes: bool) -> Vote
    where
        B: AsRef<[u8]>,
        C: AsRef<[u8]>,
    {
        // Choose secret random r.
        let r = G::Scalar::random(rand::thread_rng());
        // Select secret vote v.
        let v = if yes {
            G::Scalar::new(&BigUint::one()).unwrap()
        } else {
            G::Scalar::new(&BigUint::zero()).unwrap()
        };
        // Calculate public random R.
        let R = &self.g2 * &r;
        // Calculate public vote Z.
        let Z = &self.g1 * &(&r + &v);
        // Create PWF.
        let pwf = VoteProof::new(rng, self, yes, &r, &Z, &R, ballot_id, candidate);

        Vote {
            r: r.to_bigint(),
            v: v.to_bigint(),
            R: R.to_bigint(),
            Z: Z.to_bigint(),
            pwf,
        }
    }
}

/// Invert the given option, returning `Some(())` if it is `None`, and `None` if it is `Some(_)`.
fn ensure_none<T>(option: Option<T>) -> Option<()> {
    if option.is_none() {
        Some(())
    } else {
        None
    }
}

#[cfg(all(test, feature = "p256_impl"))]
mod tests {
    use super::*;

    use p256::NistP256;

    #[test]
    fn test_vote() {
        let mut rng = rand::thread_rng();
        let election = Election::<NistP256>::new(&[b"Test Election"], &mut rng);

        let vote1 = election.create_vote(&mut rng, "1", "Alice", true);
        assert!(vote1.verify(&election, "1", "Alice"));

        let vote2 = election.create_vote(&mut rng, "1", "Bob", false);
        assert!(vote2.verify(&election, "1", "Bob"));

        assert_ne!(vote1.pwf, vote2.pwf);
        assert!(vote2.pwf.verify(&election, &vote1.Z, &vote1.R, "1", "Bob").is_none());
        assert!(vote2.pwf.verify(&election, &vote2.Z, &vote2.R, "2", "Bob").is_none());
        assert!(vote2.pwf.verify(&election, &vote2.Z, &vote2.R, "1", "Alice").is_none());
    }

    #[test]
    fn test_ballot() {
        let mut rng = rand::thread_rng();
        let election = Election::<NistP256>::new(&[b"Woah some random bytes"], &mut rng);

        let mut ballot = election.create_ballot(&mut rng, "1", "Alice",
                                            vec!["Bob", "Eve"]).unwrap();
        assert!(ballot.verify(&election, "1"));
        assert!(!ballot.verify(&election, "2"));

        // Modify pwf and check it fails.
        ballot.pwf.r += BigUint::from(1u32);
        assert!(!ballot.verify(&election, "1"));
    }
}
