use rand::{CryptoRng, RngCore};
use std::fmt::Debug;
use std::ops::{Add, Mul, Sub};

/// Concrete implementation on the NIST P-256 elliptic curve.
#[cfg(feature = "p256_impl")]
mod p256_impl;
#[cfg(feature = "p256_impl")]
pub use p256;

/// An object that can be serialized to/from a binary blob.
pub trait Serializable {
    /// Convert self to a byte sequence.
    fn to_bytes(&self) -> Vec<u8>;

    /// Construct self from a byte sequence.
    fn from_bytes(bytes: &[u8]) -> Option<Self>
    where
        Self: Sized;

    /// Convert self to a base64-urlsafe bytestring.
    fn to_bytestring(&self) -> String {
        let bytes = self.to_bytes();
        base64::encode_config(bytes, base64::URL_SAFE_NO_PAD)
    }

    /// Construct self from a base64-urlsafe bytestring.
    fn from_bytestring(bytestring: &str) -> Option<Self>
    where
        Self: Sized,
    {
        base64::decode_config(bytestring, base64::URL_SAFE_NO_PAD)
            .ok()
            .and_then(|bytes| Self::from_bytes(&bytes))
    }
}

/// Trivial implementation of `Serializable` for `Vec<u8>`, primarily to let
/// us use `serde_bytestring` on it.
impl Serializable for Vec<u8> {
    fn to_bytes(&self) -> Vec<u8> {
        self.clone()
    }

    fn from_bytes(bytes: &[u8]) -> Option<Self>
    where
        Self: Sized,
    {
        Some(bytes.to_vec())
    }
}

/// Serde (de)serialization to/from bytestrings on types that implement Serializable.
/// Use by putting the attribute `#[serde(with = "crate::group::serde_bytestring")]`
/// on your field.
pub mod serde_bytestring {
    use serde::Deserialize;

    pub fn serialize<T, S>(bytes: &T, serializer: S) -> Result<S::Ok, S::Error>
    where
        T: super::Serializable,
        S: serde::Serializer,
    {
        serde::Serialize::serialize(&bytes.to_bytestring(), serializer)
    }

    pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
    where
        T: super::Serializable,
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer).and_then(|bytestring| {
            super::Serializable::from_bytestring(&bytestring)
                .ok_or_else(|| serde::de::Error::custom("Invalid bytestring"))
        })
    }
}

/// A point within a DRE-ip compatible group.
pub trait DreipPoint {
    /// The identity point of the group, i.e. the point at infinity, i.e. zero.
    fn identity() -> Self;
    /// Create a random point deterministically from the given data via hashing.
    fn from_hash(data: &[&[u8]]) -> Self;
}

/// A scalar within a DRE-ip compatible group.
pub trait DreipScalar {
    /// The zero scalar; the additive identity.
    fn zero() -> Self;
    /// The one scalar; the multiplicative identity.
    fn one() -> Self;
    /// Create a securely random scalar.
    fn random(rng: impl RngCore + CryptoRng) -> Self;
    /// Create a random scalar deterministically from the given data via hashing.
    fn from_hash(data: &[&[u8]]) -> Self;
}

/// A private key generated from a DRE-ip compatible group.
pub trait DreipPrivateKey {
    /// The signature produced by signing with this key.
    type Signature;

    /// Sign the given message with this key.
    fn sign(&self, msg: &[u8]) -> Self::Signature;
}

/// A public key generated from a DRE-ip compatible group.
pub trait DreipPublicKey {
    /// The signature verified by this key.
    type Signature;

    /// Verify the given message and signature with this key. Returns true if valid.
    fn verify(&self, msg: &[u8], signature: &Self::Signature) -> bool;
}

/// A DRE-ip compatible group (e.g. a DSA-like multiplicative cyclic group,
/// or an ECDSA-like additive cyclic group).
pub trait DreipGroup {
    /// The signature produced by keys from this group.
    type Signature: Serializable;
    /// A point in this group.
    type Point: DreipPoint
        + Serializable
        + Eq
        + Copy
        + Debug
        + Add<Output = Self::Point>
        + Sub<Output = Self::Point>
        + Mul<Self::Scalar, Output = Self::Point>;
    /// A scalar in this group.
    type Scalar: DreipScalar
        + Serializable
        + Eq
        + Copy
        + Debug
        + Add<Output = Self::Scalar>
        + Sub<Output = Self::Scalar>
        + Mul<Output = Self::Scalar>;
    /// A private key in this group.
    type PrivateKey: DreipPrivateKey<Signature = Self::Signature> + Serializable + Clone + Debug;
    /// A public key in this group.
    type PublicKey: DreipPublicKey<Signature = Self::Signature> + Serializable + Clone + Debug;

    /// Create two new generators deterministically from the given bytes.
    /// For optimal security, `unique_bytes` should be never be re-used in another election.
    /// One of the returned generators may be constant, but at least one of them must be
    /// deterministically generated by a one-way function from `unique_bytes`.
    fn new_generators(unique_bytes: &[&[u8]]) -> (Self::Point, Self::Point);

    /// Randomly generate a public/private keypair.
    fn new_keys(rng: impl RngCore + CryptoRng) -> (Self::PrivateKey, Self::PublicKey);
}
